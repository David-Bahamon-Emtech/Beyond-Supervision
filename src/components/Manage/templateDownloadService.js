// src/components/Manage/templateDownloadService.js
import { saveAs } from 'file-saver';

class TemplateDownloadService {
  constructor() {
    this.baseUrl = 'http://localhost:3001';
  }

  // Generate filename based on template name and format
  generateFilename(templateName, format) {
    const sanitized = templateName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const timestamp = new Date().toISOString().split('T')[0];
    return `${sanitized}_${timestamp}.${format}`;
  }

  // Convert template content to HTML format
  convertToHTML(template) {
    const isChecklist = template.type.toLowerCase().includes('checklist') || 
                       template.textContent.includes('□') || 
                       template.textContent.includes('[ ]');

    let htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${template.name}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        .header {
            border-bottom: 2px solid #2563eb;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        h1 {
            color: #1f2937;
            margin-bottom: 10px;
        }
        .metadata {
            background-color: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        .metadata p {
            margin: 5px 0;
        }
        .content {
            background-color: #f9fafb;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }
        .checklist-item {
            margin: 10px 0;
            display: flex;
            align-items: flex-start;
        }
        .checkbox {
            margin-right: 10px;
            margin-top: 2px;
        }
        .section-header {
            font-weight: bold;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #4b5563;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>${template.name}</h1>
        <p><strong>Template Type:</strong> ${template.type}</p>
    </div>
    
    <div class="metadata">
        <p><strong>Version:</strong> ${template.version}</p>
        <p><strong>Status:</strong> ${template.status}</p>
        <p><strong>Last Updated:</strong> ${this.formatDate(template.lastUpdated)}</p>
        ${template.generatedBy ? `<p><strong>Generated By:</strong> ${template.generatedBy}</p>` : ''}
    </div>
    
    <div class="content">
`;

    if (isChecklist) {
      const lines = template.textContent.split('\n');
      lines.forEach(line => {
        const trimmedLine = line.trim();
        if (trimmedLine === '') {
          htmlContent += '<br>';
        } else if (trimmedLine.startsWith('□') || trimmedLine.startsWith('[ ]') || trimmedLine.startsWith('-')) {
          const text = line.replace(/^[\s□\[\]\-]+/, '');
          htmlContent += `
        <div class="checklist-item">
            <input type="checkbox" class="checkbox">
            <label>${text}</label>
        </div>`;
        } else {
          htmlContent += `<div class="section-header">${trimmedLine}</div>`;
        }
      });
    } else {
      htmlContent += `<pre>${template.textContent}</pre>`;
    }

    htmlContent += `
    </div>
</body>
</html>`;

    return htmlContent;
  }

  // Convert template to plain text format
  convertToText(template) {
    let content = `${template.name}\n`;
    content += `${'='.repeat(template.name.length)}\n\n`;
    content += `Template Type: ${template.type}\n`;
    content += `Version: ${template.version}\n`;
    content += `Status: ${template.status}\n`;
    content += `Last Updated: ${this.formatDate(template.lastUpdated)}\n`;
    if (template.generatedBy) {
      content += `Generated By: ${template.generatedBy}\n`;
    }
    content += `\n${'─'.repeat(50)}\n\n`;
    content += template.textContent || 'No content available';
    
    return content;
  }

  // Format date helper
  formatDate(dateString) {
    if (!dateString) return 'N/A';
    const date = new Date(dateString + 'T00:00:00Z');
    const options = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
    return date.toLocaleDateString(undefined, options);
  }

  // Download template in selected format
  async downloadTemplate(template, format, options = {}) {
    try {
      switch (format) {
        case 'txt':
          return this.downloadAsText(template);
        
        case 'html':
          return this.downloadAsHTML(template);
        
        case 'pdf':
          return await this.downloadAsPDF(template, options);
        
        case 'docx':
          return await this.downloadAsDocx(template, options);
        
        default:
          throw new Error(`Unsupported format: ${format}`);
      }
    } catch (error) {
      console.error('Download error:', error);
      throw error;
    }
  }

  // Download as plain text
  downloadAsText(template) {
    const content = this.convertToText(template);
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const filename = this.generateFilename(template.name, 'txt');
    saveAs(blob, filename);
    return { success: true, filename };
  }

  // Download as HTML
  downloadAsHTML(template) {
    const content = this.convertToHTML(template);
    const blob = new Blob([content], { type: 'text/html;charset=utf-8' });
    const filename = this.generateFilename(template.name, 'html');
    saveAs(blob, filename);
    return { success: true, filename };
  }

  // Download as PDF (requires backend processing)
  async downloadAsPDF(template, options) {
    const response = await fetch(`${this.baseUrl}/api/templates/download-pdf`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        template,
        options: {
          includeMetadata: options.includeMetadata !== false,
          includeHeader: options.includeHeader !== false,
          includeFooter: options.includeFooter !== false,
        }
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to generate PDF');
    }

    const blob = await response.blob();
    const filename = this.generateFilename(template.name, 'pdf');
    saveAs(blob, filename);
    return { success: true, filename };
  }

  // Download as DOCX (requires backend processing)
  async downloadAsDocx(template, options) {
    const response = await fetch(`${this.baseUrl}/api/templates/download-docx`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        template,
        options: {
          includeMetadata: options.includeMetadata !== false,
          includeHeader: options.includeHeader !== false,
          includeStyles: options.includeStyles !== false,
        }
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to generate DOCX');
    }

    const blob = await response.blob();
    const filename = this.generateFilename(template.name, 'docx');
    saveAs(blob, filename);
    return { success: true, filename };
  }

  // Batch download multiple templates
  async downloadBatch(templates, format, options = {}) {
    const results = [];
    const errors = [];

    for (const template of templates) {
      try {
        const result = await this.downloadTemplate(template, format, options);
        results.push({ template: template.name, ...result });
      } catch (error) {
        errors.push({ template: template.name, error: error.message });
      }
    }

    return { results, errors };
  }
}

export default new TemplateDownloadService();